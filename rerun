#!/usr/bin/env python
#
# Rerun is a Gtk+3 application launcher, command runner, root runner and
# graphics switcher (run application with PRIME turned on). BUT thats all
# it does. No added features, not many bug fixes or anything else.
# No bloat whatsoever, no feature creep.
# Licensing and other notes at the end.
from __future__ import print_function
import sys
import os  # basics
try:
    import gi
    gi.require_version('Gtk', '3.0')  # inform the PC that we need GTK+ 3.
    from gi.repository import Gtk  # this is the GNOME depends
except ImportError as imper:
    print("Importing GObject failed!")
    print("Install GObject bindings.")
    print(imper)
    sys.exit(0)


def gload():
    global builder
    PATH = os.path.dirname(os.path.realpath(__file__))
    GLADEFILE = PATH + "/rerun.ui"
    builder = Gtk.Builder()
    builder.add_from_file(GLADEFILE)
    window = builder.get_object('rerun')  # main window
    window.show_all()


gload()
import subprocess  # for processes.
import threading
# ^ Yea. I just violated PEP8 to get a savings of about 300 ms.
command = builder.get_object('command')
pron = builder.get_object('pron')
proff = builder.get_object('proff')
prdefault = builder.get_object('prdefault')
rootpass = builder.get_object('rootpass')
pkexecopt = builder.get_object('pkexecopt')
sudopt = builder.get_object('sudopt')
rootpass.set_sensitive(False)
pkexecopt.set_sensitive(False)
sudopt.set_sensitive(False)


class thready(threading.Thread):
    def __init__(self, cmd, sin=None, root=False, rpass=None):
        threading.Thread.__init__(self)
        self.cmd = cmd
        self.root = root
        self.rpass = rpass
        self.sin = sin

    def run(self):
        NULLMAKER = open(os.devnull, 'w')
        # ^ This is needed for ignoring unwanted terminal output.
        p = subprocess.Popen(self.cmd, shell=True,
                             stdin=self.sin,
                             stdout=NULLMAKER,
                             stderr=subprocess.STDOUT,
                             universal_newlines=True)
        if self.root:
            p.stdin.write(self.rpass + '\n')
            p.stdin.close()


class rerunmain():
    def on_window_destroy(self, rerun):
        Gtk.main_quit()

    def pktoggle(self, pkexecopt):
        rootpass.set_sensitive(False)

    def sutoggle(self, sudopt):
        rootpass.set_sensitive(True)

    def switched(self, rootrun, crap=None):
        rootrun = builder.get_object('rootrun')
        if rootrun.get_active():
            pkexecopt.set_sensitive(True)
            sudopt.set_sensitive(True)
        else:
            pkexecopt.set_sensitive(False)
            sudopt.set_sensitive(False)

    def regrun(self):
        if prdefault.get_active():
            thread = thready(command.get_text())
        elif pron.get_active():
            thread = thready("env DRI_PRIME=1 " + command.get_text())
        elif proff.get_active():
            thread = thready("env DRI_PRIME=0 " + command.get_text())
        thread.start()
        thread.join()

    def sudorun(self):
        if prdefault.get_active():
            if rootpass.get_sensitive():
                thread = thready('sudo -S "' + command.get_text().strip() +
                                 '"', subprocess.PIPE, True,
                                 rootpass.get_text())
            else:
                thread = thready('pkexec "' + command.get_text().strip() +
                                 '"')
        elif pron.get_active():
            thread = self.primeroot(rootpass, command, 1)
        elif proff.get_active():
            thread = self.primeroot(rootpass, command, 0)
        thread.start()
        thread.join()

    def primeroot(self, rootpass, command, primeval):
        if rootpass.get_sensitive():
            thread = thready("env DRI_PRIME=" + str(primeval) + " " +
                             'sudo -S "' + command.get_text().strip() +
                             '"', subprocess.PIPE, True,
                             rootpass.get_text())
        else:
            thread = thready("env DRI_PRIME=" + str(primeval) + " " +
                             'pkexec "' + command.get_text().strip() +
                             '"')
        return thread

    def on_run_clicked(self, run):
        rootrun = builder.get_object('rootrun')
        try:
            if not command.get_text().strip() == '':
                if not rootrun.get_active():
                    self.regrun()
                else:
                    self.sudorun()
        except Exception as exe:
            print('Failed to run command!')
            print(exe)

    def xfixpress(self, xfixbutton):
        try:
            subprocess.Popen("xhost si:localuser:root", shell=True)
        except Exception as exe:
            print("Running the command failed. Something wrong with")
            print("your PC? This shouldn't be happening. Error:")
            print(exe)


builder.connect_signals(rerunmain())
Gtk.main()

# Additional Notes and such:
# 1. shell=True..... Yes. Yes. Its normally unsafe and not recomended but
#    in this case, its perfectly safe as no stdin is never accepted and
#    is not saved. Please correct me if I'm wrong. Read (7) for exception.
#
# 2. NULLMAKER is a variable to /dev/null, this is where output is mostly
#    redirected to.
#
# 3. sudo vs gksudo and similar alternatives: As of now, gksudo, kdesudo,
#    etc have been deprecated. But sudo still remains a feasible option.
#    pkexec would have been a better option but it does not work with
#    GUI applications on Wayland.
#
# 4. The code is structured based on suggestions from PEP8 and McCabe
#    Complexity Check. So, this is as simple as it can get.
#
# 5. DEPRECATED, NON-MULTITHREADED CODE FOR REFERENCE:
#    ___________________________________________________________________
#    subprocess.Popen('sudo -S "' + command.get_text().strip() +
#                     '"', stdout=NULLMAKER, stdin=subprocess.PIPE,
#                     stderr=subprocess.STDOUT, universal_newlines=True,
#                     shell=True).communicate(rootpass.get_text() +
#                                             '\n')
#    ___________________________________________________________________
#
# 6. Why mulithreading? Because then, it won't freeze the app and its better
#    at things like memory management To confirm, use above deprecated code
#    to root-run Nautilus.
#
# 7. STDIN in root-run: This pipe is closed immediately after password input
#    and thus, should be safe. I'm ok with corrections as said earlier.
#
# LICENSING:
#
# Rerun
# Copyright (C) 2017 Mufeed Ali [nightglare/mufeed20] <mufeed.ali53@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
#
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
